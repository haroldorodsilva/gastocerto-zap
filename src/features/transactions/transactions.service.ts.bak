import { Injectable, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { EventEmitter2 } from '@nestjs/event-emitter';
import { PrismaService } from '@common/prisma.service';
import { AIProviderFactory } from '../ai/ai-provider.factory';
import { TransactionValidatorService } from './transaction-validator.service';
import { TransactionConfirmationService } from './transaction-confirmation.service';
import { GastoCertoApiService } from '../users/gasto-certo-api.service';
import { UserCacheService } from '../users/user-cache.service';
import { IntentAnalyzerService, MessageIntent } from '../intent/intent-analyzer.service';
import { TransactionData } from '../ai/ai.interface';
import { UserCache, TransactionConfirmation } from '@prisma/client';
import {
  CreateTransactionConfirmationDto,
  CreateGastoCertoTransactionDto,
} from './dto/transaction.dto';

export interface ProcessMessageResult {
  success: boolean;
  message: string;
  requiresConfirmation: boolean;
  confirmationId?: string;
  autoRegistered?: boolean;
}

@Injectable()
export class TransactionsService {
  private readonly logger = new Logger(TransactionsService.name);
  private readonly requireConfirmation: boolean;
  private readonly autoRegisterThreshold: number;
  private readonly minConfidenceThreshold: number;

  constructor(
    private readonly prisma: PrismaService,
    private readonly aiFactory: AIProviderFactory,
    private readonly validator: TransactionValidatorService,
    private readonly confirmationService: TransactionConfirmationService,
    private readonly gastoCertoApi: GastoCertoApiService,
    private readonly userCache: UserCacheService,
    private readonly configService: ConfigService,
    private readonly intentAnalyzer: IntentAnalyzerService,
    private readonly eventEmitter: EventEmitter2,
  ) {
    this.requireConfirmation = this.configService.get<boolean>('REQUIRE_CONFIRMATION', true);
    this.autoRegisterThreshold = this.configService.get<number>('AUTO_REGISTER_THRESHOLD', 0.8);
    this.minConfidenceThreshold = this.configService.get<number>('MIN_CONFIDENCE_THRESHOLD', 0.5);

    this.logger.log(
      `üéØ Configura√ß√£o de confirma√ß√µes: ` +
        `requireConfirmation=${this.requireConfirmation}, ` +
        `autoRegisterThreshold=${this.autoRegisterThreshold}, ` +
        `minConfidenceThreshold=${this.minConfidenceThreshold}`,
    );
  }

  /**
   * ‚ú® Helper para emitir eventos de resposta para o usu√°rio
   * 
   * Usa platformId (phoneNumber) para garantir roteamento correto via MessageContextService
   */
  private emitReply(
    platformId: string,
    message: string,
    context: 'INTENT_RESPONSE' | 'CONFIRMATION_REQUEST' | 'TRANSACTION_RESULT' | 'ERROR',
    metadata?: any,
  ): void {
    this.eventEmitter.emit('message.reply', {
      platformId, // Usando platformId ao inv√©s de phoneNumber
      message,
      context,
      metadata,
    });
  }

  /**
   * Helper para tratar erros de IA de forma amig√°vel
   */
  private handleAIError(error: any, context: 'texto' | 'imagem' | '√°udio'): string {
    const errorMessage = error.message || '';

    // Erro de rate limit
    if (errorMessage.includes('Rate limit atingido')) {
      return (
        '‚è∞ *Muitas requisi√ß√µes no momento*\n\n' +
        'Estamos processando muitas mensagens. Por favor, aguarde alguns instantes e tente novamente.\n\n' +
        '_Se o problema persistir, entre em contato com o suporte._'
      );
    }

    // Erro de fallback n√£o configurado (provider principal falhou)
    if (errorMessage.includes('Configure AI_FALLBACK_ENABLED')) {
      return (
        'ü§ñ *Servi√ßo de IA temporariamente indispon√≠vel*\n\n' +
        'Estamos com problema no processamento de mensagens. Nossa equipe j√° foi notificada.\n\n' +
        'Por favor, tente novamente em alguns minutos.'
      );
    }

    // Erro de quota/cr√©ditos (OpenAI, Gemini, etc)
    if (
      errorMessage.includes('quota') ||
      errorMessage.includes('insufficient_quota') ||
      errorMessage.includes('billing')
    ) {
      return (
        'üí≥ *Limite de processamento atingido*\n\n' +
        'Atingimos o limite de processamento de IA para este per√≠odo.\n\n' +
        'Nossa equipe j√° foi notificada e o servi√ßo ser√° restabelecido em breve.\n\n' +
        '_Desculpe pelo inconveniente._'
      );
    }

    // Erro de timeout
    if (errorMessage.includes('timeout') || errorMessage.includes('timed out')) {
      return (
        '‚è±Ô∏è *Tempo esgotado*\n\n' +
        'O processamento est√° demorando mais que o esperado.\n\n' +
        'Por favor, tente novamente.'
      );
    }

    // Erro gen√©rico por tipo de m√≠dia
    const contextMessages = {
      texto:
        '‚ùå *N√£o consegui processar sua mensagem*\n\n' +
        'Ocorreu um erro inesperado. Por favor:\n' +
        '1. Tente reformular sua mensagem\n' +
        '2. Se o problema persistir, entre em contato com o suporte\n\n' +
        '_Exemplo: "Gastei 50 reais em alimenta√ß√£o no mercado"_',
      imagem:
        '‚ùå *N√£o consegui processar a imagem*\n\n' +
        'Ocorreu um erro ao analisar a imagem. Por favor:\n' +
        '1. Tente enviar a imagem novamente\n' +
        '2. Certifique-se que a imagem est√° leg√≠vel\n' +
        '3. Ou digite manualmente: "Gastei 50 reais em alimenta√ß√£o"',
      √°udio:
        '‚ùå *N√£o consegui processar o √°udio*\n\n' +
        'Ocorreu um erro ao transcrever o √°udio. Por favor:\n' +
        '1. Tente gravar o √°udio novamente\n' +
        '2. Fale de forma clara\n' +
        '3. Ou digite manualmente: "Gastei 50 reais em alimenta√ß√£o"',
    };

    return contextMessages[context];
  }

  /**
   * Processa mensagem de texto e extrai transa√ß√£o
   */
  async processTextMessage(
    phoneNumber: string,
    text: string,
    messageId: string,
  ): Promise<ProcessMessageResult> {
    try {
      this.logger.log(`üìù Processando texto de ${phoneNumber}: "${text}"`);

      // 1. Buscar usu√°rio
      const user = await this.userCache.getUser(phoneNumber);
      if (!user) {
        return {
          success: false,
          message: '‚ùå Usu√°rio n√£o encontrado. Complete o cadastro primeiro.',
          requiresConfirmation: false,
        };
      }

      // 2. Analisar inten√ß√£o da mensagem com NLP ANTES de chamar IA
      this.logger.log(`üß† Analisando inten√ß√£o da mensagem com NLP...`);
      const intentResult = await this.intentAnalyzer.analyzeIntent(text, phoneNumber, user.id);

      this.logger.log(
        `üéØ Intent detectado: ${intentResult.intent} | Confian√ßa: ${(intentResult.confidence * 100).toFixed(1)}% | Processar com IA: ${intentResult.shouldProcess ? 'SIM' : 'N√ÉO'}`,
      );

      // Se NLP detectou que N√ÉO √© transa√ß√£o, retornar resposta sugerida
      if (!intentResult.shouldProcess) {
        this.logger.log(`‚õî Mensagem n√£o ser√° processada pela IA - Retornando sugest√£o`);

        const responseMessage =
          intentResult.suggestedResponse ||
          'Mensagem recebida. Para registrar transa√ß√µes, envie algo como: "Gastei R$50 no mercado"';

        // Emitir evento para enviar resposta ao usu√°rio
        this.emitReply(phoneNumber, responseMessage, 'INTENT_RESPONSE', {
          intent: intentResult.intent,
          confidence: intentResult.confidence,
        });

        return {
          success: true,
          message: responseMessage,
          requiresConfirmation: false,
        };
      }

      this.logger.log(`‚úÖ Inten√ß√£o v√°lida para processamento com IA`);

      // 3. Buscar categorias completas (com accounts se necess√°rio)
      this.logger.log(`üîç Buscando categorias para an√°lise de transa√ß√£o...`);
      const categoriesData = await this.userCache.getUserCategories(phoneNumber);

      this.logger.log(
        `üìä Categorias dispon√≠veis: ${categoriesData.categories.length} categoria(s) de ${categoriesData.accounts.length} conta(s)`,
      );

      if (categoriesData.hasCategories) {
        // Log das categorias para an√°lise
        categoriesData.categories.forEach((cat: any) => {
          this.logger.log(
            `  üìÇ ${cat.name} (ID: ${cat.id}) - Tipo: ${cat.type} - Conta: ${cat.accountName || 'N/A'} (Default: ${cat.isDefaultAccount ? 'Sim' : 'N√£o'})`,
          );
        });
      }

      // 3. Extrair dados com IA
      let transactionData: TransactionData;
      let responseTime: number;

      try {
        const startTime = Date.now();
        transactionData = await this.aiFactory.extractTransaction(text, {
          name: user.name,
          email: user.email,
          categories: categoriesData.categories,
        });
        responseTime = Date.now() - startTime;

        // Estimar tokens (aproximado: 1 token ‚âà 4 caracteres)
        const inputTokens = Math.ceil(text.length / 4);
        const outputTokens = Math.ceil(JSON.stringify(transactionData).length / 4);

        // Registrar uso de IA
        await this.aiFactory.logAIUsage({
          phoneNumber,
          userCacheId: user.id,
          operation: 'TRANSACTION_EXTRACTION',
          inputType: 'TEXT',
          inputText: text,
          inputTokens,
          outputTokens,
          metadata: {
            confidence: transactionData.confidence,
            category: transactionData.category,
            amount: transactionData.amount,
            type: transactionData.type,
            responseTimeMs: responseTime,
          },
        });
      } catch (aiError: any) {
        this.logger.error(`‚ùå Erro ao processar com IA: ${aiError.message}`, aiError.stack);

        // Identificar tipo de erro
        let errorMessage = '‚ùå *Erro ao processar sua mensagem*\n\n';
        let errorType = 'ai_error';

        if (aiError.message?.includes('timeout') || aiError.message?.includes('ETIMEDOUT')) {
          errorType = 'ai_timeout';
          errorMessage +=
            '‚è±Ô∏è A intelig√™ncia artificial demorou muito para responder.\n\n' +
            'Por favor, tente novamente em alguns instantes.';
        } else if (aiError.message?.includes('rate limit') || aiError.message?.includes('429')) {
          errorType = 'ai_rate_limit';
          errorMessage +=
            'üö¶ Muitas requisi√ß√µes em pouco tempo.\n\n' +
            'Aguarde alguns segundos e tente novamente.';
        } else if (aiError.message?.includes('API key') || aiError.message?.includes('401')) {
          errorType = 'ai_auth_error';
          errorMessage +=
            'üîê Erro de autentica√ß√£o com a IA.\n\n' + 'Entre em contato com o suporte t√©cnico.';
        } else {
          errorMessage +=
            'ü§ñ Ocorreu um erro inesperado ao processar sua mensagem.\n\n' +
            'Por favor, tente reformular e enviar novamente.\n\n' +
            '*Dica:* Use o formato "Gastei R$50 no mercado"';
        }

        // Emitir evento de erro
        this.eventEmitter.emit('message.reply', {
          phoneNumber,
          message: errorMessage,
          context: 'ERROR',
          metadata: {
            errorType,
            errorMessage: aiError.message,
            originalText: text,
          },
        });

        return {
          success: false,
          message: errorMessage,
          requiresConfirmation: false,
        };
      }

      this.logger.log(`\nü§ñ ========== RESULTADO EXTRA√á√ÉO IA ==========`);
      this.logger.log(
        `üí∞ Tipo: ${transactionData.type} | Valor: R$ ${(transactionData.amount / 100).toFixed(2)}`,
      );
      this.logger.log(`üìÇ Categoria extra√≠da: "${transactionData.category}"`);
      this.logger.log(`üìù Descri√ß√£o: "${transactionData.description || 'N/A'}"`);
      this.logger.log(`üéØ Confidence: ${(transactionData.confidence * 100).toFixed(0)}%`);
      this.logger.log(`=============================================\n`);

      // 4. Validar dados extra√≠dos
      const validation = this.validator.validate(transactionData);
      if (!validation.isValid) {
        return {
          success: false,
          message: `‚ùå N√£o consegui entender a transa√ß√£o:\n${validation.errors.join('\n')}`,
          requiresConfirmation: false,
        };
      }

      // 5. Verificar confidence e decidir fluxo
      const confidence = transactionData.confidence;

      // 5.1. Rejeitar se confidence muito baixo
      if (confidence < this.minConfidenceThreshold) {
        this.logger.warn(
          `‚ö†Ô∏è Confidence muito baixo (${(confidence * 100).toFixed(0)}%) - Rejeitando transa√ß√£o`,
        );
        return {
          success: false,
          message:
            `‚ùå N√£o tenho certeza suficiente sobre essa transa√ß√£o (${(confidence * 100).toFixed(0)}% de confian√ßa).\n\n` +
            `Por favor, tente reformular de forma mais clara. Exemplo:\n` +
            `"Gastei 50 reais em alimenta√ß√£o no mercado"`,
          requiresConfirmation: false,
        };
      }

      // 5.2. Auto-registrar se:
      //      - Confirma√ß√µes desabilitadas globalmente OU
      //      - Confidence alto suficiente
      const shouldAutoRegister =
        !this.requireConfirmation || confidence >= this.autoRegisterThreshold;

      if (shouldAutoRegister) {
        this.logger.log(
          `‚úÖ Auto-registrando transa√ß√£o (confidence: ${(confidence * 100).toFixed(0)}%)`,
        );

        // Emitir evento IMEDIATO informando que est√° processando
        const typeEmoji = transactionData.type === 'EXPENSES' ? 'üí∏' : 'üí∞';
        const typeText = transactionData.type === 'EXPENSES' ? 'Gasto' : 'Receita';
        const amountFormatted = this.validator.formatAmount(transactionData.amount);

        this.eventEmitter.emit('message.reply', {
          phoneNumber,
          message:
            `ü§ñ *${typeText} detectado com alta confian√ßa!*\n\n` +
            `${typeEmoji} *Valor:* ${amountFormatted}\n` +
            `üìÇ *Categoria:* ${transactionData.category}\n` +
            `${transactionData.description ? `üìù *Descri√ß√£o:* ${transactionData.description}\n` : ''}` +
            `\n‚è≥ Registrando automaticamente...`,
          context: 'INTENT_RESPONSE',
          metadata: {
            action: 'auto_register_started',
            confidence,
          },
        });

        // Criar confirma√ß√£o tempor√°ria para registro
        const tempConfirmation = await this.createConfirmation(
          phoneNumber,
          messageId,
          transactionData,
        );

        // Registrar imediatamente
        const registerResult = await this.registerTransaction(tempConfirmation);

        // O registerTransaction j√° emite o evento de sucesso/erro final
        // ent√£o n√£o precisamos emitir novamente aqui

        return {
          success: registerResult.success,
          message: registerResult.message,
          requiresConfirmation: false,
          autoRegistered: true,
        };
      }

      // 4.3. Pedir confirma√ß√£o (confidence m√©dio)
      this.logger.log(`‚ùì Solicitando confirma√ß√£o (confidence: ${(confidence * 100).toFixed(0)}%)`);

      const confirmation = await this.createConfirmation(phoneNumber, messageId, transactionData);

      // 5. Formatar mensagem de confirma√ß√£o
      const confirmationMessage = this.confirmationService.formatConfirmationMessage(confirmation);

      // Adicionar avisos se houver
      let finalMessage = confirmationMessage;
      if (validation.warnings.length > 0) {
        finalMessage += `\n\n‚ö†Ô∏è *Avisos:*\n${validation.warnings.join('\n')}`;
      }

      // Emitir evento para enviar mensagem de confirma√ß√£o
      this.eventEmitter.emit('message.reply', {
        phoneNumber,
        message: finalMessage,
        context: 'CONFIRMATION_REQUEST',
        metadata: {
          confirmationId: confirmation.id,
          confidence,
        },
      });

      return {
        success: true,
        message: finalMessage,
        requiresConfirmation: true,
        confirmationId: confirmation.id,
      };
    } catch (error) {
      this.logger.error('Erro ao processar mensagem de texto:', error);
      return {
        success: false,
        message: this.handleAIError(error, 'texto'),
        requiresConfirmation: false,
      };
    }
  }

  /**
   * Processa imagem (NFe, comprovante)
   */
  async processImageMessage(
    phoneNumber: string,
    imageBuffer: Buffer,
    mimeType: string,
    messageId: string,
  ): Promise<ProcessMessageResult> {
    try {
      this.logger.log(`üì∏ Processando imagem de ${phoneNumber}`);

      // 1. Buscar usu√°rio
      const user = await this.userCache.getUser(phoneNumber);
      if (!user) {
        return {
          success: false,
          message: '‚ùå Usu√°rio n√£o encontrado. Complete o cadastro primeiro.',
          requiresConfirmation: false,
        };
      }

      // 2. Validar tamanho da imagem (max 10MB)
      const maxSize = 10 * 1024 * 1024; // 10MB
      if (imageBuffer.length > maxSize) {
        return {
          success: false,
          message: '‚ùå Imagem muito grande (m√°x: 10MB).\n\nCompacte a imagem ou tire uma foto com menor qualidade.',
          requiresConfirmation: false,
        };
      }

      // 3. Analisar imagem com IA
      let transactionData: TransactionData;
      try {
        const startTime = Date.now();
        transactionData = await this.aiFactory.analyzeImage(imageBuffer, mimeType);
        const responseTime = Date.now() - startTime;

        this.logger.log(
          `üì∏ Imagem analisada em ${responseTime}ms | Confidence: ${(transactionData.confidence * 100).toFixed(0)}%`,
        );
      } catch (aiError: any) {
        this.logger.error(`‚ùå Erro ao analisar imagem com IA: ${aiError.message}`, aiError.stack);

        let errorMessage = '‚ùå *Erro ao processar imagem*\n\n';

        if (aiError.message?.includes('timeout') || aiError.message?.includes('ETIMEDOUT')) {
          errorMessage +=
            '‚è±Ô∏è A an√°lise da imagem demorou muito.\n\nTente novamente ou digite os dados manualmente.';
        } else if (aiError.message?.includes('rate limit') || aiError.message?.includes('429')) {
          errorMessage += 'üö¶ Muitas requisi√ß√µes. Aguarde alguns segundos e tente novamente.';
        } else {
          errorMessage +=
            'ü§ñ N√£o consegui processar a imagem.\n\n*Dicas:*\n‚Ä¢ Envie uma imagem mais clara\n‚Ä¢ Tire foto com boa ilumina√ß√£o\n‚Ä¢ Ou digite os dados manualmente';
        }

        this.eventEmitter.emit('message.reply', {
          phoneNumber,
          message: errorMessage,
          context: 'ERROR',
          metadata: {
            errorType: 'ai_image_error',
            errorMessage: aiError.message,
          },
        });

        return {
          success: false,
          message: errorMessage,
          requiresConfirmation: false,
        };
      }

      // 4. Validar dados extra√≠dos
      const validation = this.validator.validate(transactionData);
      if (!validation.isValid) {
        const errorMessage =
          `‚ùå *N√£o consegui extrair dados v√°lidos da imagem*\n\n` +
          `${validation.errors.join('\n')}\n\n` +
          `*Dicas:*\n` +
          `‚Ä¢ Envie uma foto mais clara da nota fiscal\n` +
          `‚Ä¢ Certifique-se que o valor est√° vis√≠vel\n` +
          `‚Ä¢ Ou digite: "Gastei R$50 no mercado"`;

        this.eventEmitter.emit('message.reply', {
          phoneNumber,
          message: errorMessage,
          context: 'ERROR',
          metadata: {
            errorType: 'validation_error',
            errors: validation.errors,
            confidence: transactionData.confidence,
          },
        });

        return {
          success: false,
          message: errorMessage,
          requiresConfirmation: false,
        };
      }

      // 5. Verificar confian√ßa muito baixa
      if (transactionData.confidence < 0.5) {
        const errorMessage =
          `‚ùå *Confian√ßa muito baixa na extra√ß√£o* (${(transactionData.confidence * 100).toFixed(0)}%)\n\n` +
          `A imagem est√° muito borrada ou n√£o √© uma nota fiscal v√°lida.\n\n` +
          `*Por favor:*\n` +
          `‚Ä¢ Envie uma imagem mais clara\n` +
          `‚Ä¢ Tire foto com melhor ilumina√ß√£o\n` +
          `‚Ä¢ Ou digite os dados manualmente`;

        this.eventEmitter.emit('message.reply', {
          phoneNumber,
          message: errorMessage,
          context: 'ERROR',
          metadata: {
            errorType: 'low_confidence',
            confidence: transactionData.confidence,
          },
        });

        return {
          success: false,
          message: errorMessage,
          requiresConfirmation: false,
        };
      }

      // 6. Criar confirma√ß√£o pendente
      const confirmation = await this.createConfirmation(phoneNumber, messageId, transactionData);

      // 7. Formatar mensagem de confirma√ß√£o
      let message = 'üì∏ *Dados extra√≠dos da imagem:*\n\n';
      message += this.confirmationService.formatConfirmationMessage(confirmation);

      // Adicionar avisos
      if (validation.warnings.length > 0) {
        message += `\n\n‚ö†Ô∏è *Avisos:*\n${validation.warnings.join('\n')}`;
      }

      if (transactionData.confidence < 0.7) {
        message += '\n\n‚ö†Ô∏è *Confian√ßa m√©dia na extra√ß√£o. Por favor, revise os dados.*';
      }

      // Emitir evento para enviar confirma√ß√£o
      this.eventEmitter.emit('message.reply', {
        phoneNumber,
        message,
        context: 'CONFIRMATION_REQUEST',
        metadata: {
          confirmationId: confirmation.id,
          confidence: transactionData.confidence,
          fromImage: true,
        },
      });

      return {
        success: true,
        message,
        requiresConfirmation: true,
        confirmationId: confirmation.id,
      };
    } catch (error: any) {
      this.logger.error('Erro ao processar imagem:', error);

      const errorMessage =
        '‚ùå *Erro inesperado ao processar imagem*\n\n' +
        'Por favor, tente novamente ou digite os dados manualmente.';

      this.eventEmitter.emit('message.reply', {
        phoneNumber,
        message: errorMessage,
        context: 'ERROR',
        metadata: {
          errorType: 'exception',
          errorMessage: error.message,
        },
      });

      return {
        success: false,
        message: errorMessage,
        requiresConfirmation: false,
      };
    }
  }

  /**
   * Processa √°udio (transcreve e extrai transa√ß√£o)
   */
  async processAudioMessage(
    phoneNumber: string,
    audioBuffer: Buffer,
    mimeType: string,
    messageId: string,
  ): Promise<ProcessMessageResult> {
    try {
      this.logger.log(`üé§ Processando √°udio de ${phoneNumber}`);

      // 1. Buscar usu√°rio
      const user = await this.userCache.getUser(phoneNumber);
      if (!user) {
        return {
          success: false,
          message: '‚ùå Usu√°rio n√£o encontrado. Complete o cadastro primeiro.',
          requiresConfirmation: false,
        };
      }

      // 2. Estimar dura√ß√£o do √°udio (aproxima√ß√£o: 16kHz mono)
      const estimatedDurationSeconds = audioBuffer.length / 16000;
      const maxDurationSeconds = 120; // 2 minutos

      this.logger.log(
        `üé§ Dura√ß√£o estimada do √°udio: ${estimatedDurationSeconds.toFixed(1)}s (max: ${maxDurationSeconds}s)`,
      );

      // 3. Validar dura√ß√£o - √°udios muito longos provavelmente n√£o s√£o transa√ß√µes
      if (estimatedDurationSeconds > maxDurationSeconds) {
        const errorMessage =
          `‚è±Ô∏è *√Åudio muito longo* (${Math.floor(estimatedDurationSeconds)}s)\n\n` +
          `√Åudios de transa√ß√µes geralmente t√™m menos de 2 minutos.\n\n` +
          `*Por favor:*\n` +
          `‚Ä¢ Envie um √°udio mais curto\n` +
          `‚Ä¢ Ou digite: "Gastei R$50 no mercado"`;

        this.eventEmitter.emit('message.reply', {
          phoneNumber,
          message: errorMessage,
          context: 'ERROR',
          metadata: {
            errorType: 'audio_too_long',
            durationSeconds: estimatedDurationSeconds,
            maxDurationSeconds,
          },
        });

        return {
          success: false,
          message: errorMessage,
          requiresConfirmation: false,
        };
      }

      // 4. Transcrever √°udio
      let transcription: string;
      try {
        const startTimeAudio = Date.now();
        transcription = await this.aiFactory.transcribeAudio(audioBuffer, mimeType);
        const responseTimeAudio = Date.now() - startTimeAudio;

        // Estimar tokens para √°udio (1 minuto ‚âà 150-200 tokens)
        const audioTokens = Math.ceil((estimatedDurationSeconds / 60) * 175);

        // Registrar transcri√ß√£o de √°udio
        await this.aiFactory.logAIUsage({
          phoneNumber,
          userCacheId: user.id,
          operation: 'AUDIO_TRANSCRIPTION',
          inputType: 'AUDIO',
          inputTokens: audioTokens,
          outputTokens: Math.ceil(transcription.length / 4),
          metadata: {
            transcription,
            mimeType,
            bufferSize: audioBuffer.length,
            durationSeconds: estimatedDurationSeconds,
            responseTimeMs: responseTimeAudio,
          },
        });

        this.logger.log(`üé§ Transcri√ß√£o (${responseTimeAudio}ms): "${transcription}"`);
      } catch (aiError: any) {
        this.logger.error(`‚ùå Erro ao transcrever √°udio: ${aiError.message}`, aiError.stack);

        let errorMessage = '‚ùå *Erro ao transcrever √°udio*\n\n';

        if (aiError.message?.includes('timeout') || aiError.message?.includes('ETIMEDOUT')) {
          errorMessage += '‚è±Ô∏è A transcri√ß√£o demorou muito. Tente enviar um √°udio mais curto.';
        } else if (aiError.message?.includes('rate limit') || aiError.message?.includes('429')) {
          errorMessage += 'üö¶ Muitas requisi√ß√µes. Aguarde alguns segundos e tente novamente.';
        } else {
          errorMessage +=
            'ü§ñ N√£o consegui processar o √°udio.\n\n*Dicas:*\n‚Ä¢ Grave em ambiente silencioso\n‚Ä¢ Fale mais pr√≥ximo do microfone\n‚Ä¢ Ou digite a mensagem';
        }

        this.eventEmitter.emit('message.reply', {
          phoneNumber,
          message: errorMessage,
          context: 'ERROR',
          metadata: {
            errorType: 'ai_audio_transcription_error',
            errorMessage: aiError.message,
            durationSeconds: estimatedDurationSeconds,
          },
        });

        return {
          success: false,
          message: errorMessage,
          requiresConfirmation: false,
        };
      }

      // 5. Validar transcri√ß√£o
      if (!transcription || transcription.trim().length === 0) {
        const errorMessage =
          '‚ùå *N√£o consegui entender o √°udio*\n\n' +
          'O √°udio est√° muito baixo ou com muito ru√≠do.\n\n' +
          '*Por favor:*\n' +
          '‚Ä¢ Grave em local silencioso\n' +
          '‚Ä¢ Fale mais pr√≥ximo do microfone\n' +
          '‚Ä¢ Ou digite a mensagem';

        this.eventEmitter.emit('message.reply', {
          phoneNumber,
          message: errorMessage,
          context: 'ERROR',
          metadata: {
            errorType: 'empty_transcription',
            durationSeconds: estimatedDurationSeconds,
          },
        });

        return {
          success: false,
          message: errorMessage,
          requiresConfirmation: false,
        };
      }

      // 6. Buscar categorias completas (com accounts se necess√°rio)
      this.logger.log(`üîç Buscando categorias para an√°lise de transa√ß√£o de √°udio...`);
      const categoriesData = await this.userCache.getUserCategories(phoneNumber);

      this.logger.log(
        `üìä Categorias dispon√≠veis: ${categoriesData.categories.length} categoria(s) de ${categoriesData.accounts.length} conta(s)`,
      );

      if (categoriesData.hasCategories) {
        categoriesData.categories.forEach((cat: any) => {
          this.logger.log(
            `  üìÇ ${cat.name} (ID: ${cat.id}) - Tipo: ${cat.type} - Conta: ${cat.accountName || 'N/A'} (Default: ${cat.isDefaultAccount ? 'Sim' : 'N√£o'})`,
          );
        });
      }

      // 7. Extrair transa√ß√£o do texto transcrito
      let transactionData: TransactionData;
      try {
        const startTimeExtract = Date.now();
        transactionData = await this.aiFactory.extractTransaction(transcription, {
          name: user.name,
          email: user.email,
          categories: categoriesData.categories,
        });
        const responseTimeExtract = Date.now() - startTimeExtract;

        // Registrar extra√ß√£o de transa√ß√£o
        await this.aiFactory.logAIUsage({
          phoneNumber,
          userCacheId: user.id,
          operation: 'TRANSACTION_EXTRACTION',
          inputType: 'TEXT',
          inputText: transcription,
          inputTokens: Math.ceil(transcription.length / 4),
          outputTokens: Math.ceil(JSON.stringify(transactionData).length / 4),
          metadata: {
            confidence: transactionData.confidence,
            category: transactionData.category,
            amount: transactionData.amount,
            type: transactionData.type,
            responseTimeMs: responseTimeExtract,
            fromAudio: true,
          },
        });

        this.logger.log(
          `ü§ñ Extra√ß√£o (${responseTimeExtract}ms) | Confidence: ${(transactionData.confidence * 100).toFixed(0)}%`,
        );
      } catch (aiError: any) {
        this.logger.error(`‚ùå Erro ao extrair transa√ß√£o do √°udio: ${aiError.message}`, aiError.stack);

        let errorMessage = `‚ùå *Erro ao processar transcri√ß√£o*\n\nüé§ Ouvi: "${transcription}"\n\n`;

        if (aiError.message?.includes('timeout') || aiError.message?.includes('ETIMEDOUT')) {
          errorMessage += '‚è±Ô∏è A an√°lise demorou muito. Tente novamente ou digite a mensagem.';
        } else if (aiError.message?.includes('rate limit') || aiError.message?.includes('429')) {
          errorMessage += 'üö¶ Muitas requisi√ß√µes. Aguarde alguns segundos e tente novamente.';
        } else {
          errorMessage += 'N√£o consegui entender a transa√ß√£o. Por favor, digite manualmente.';
        }

        this.eventEmitter.emit('message.reply', {
          phoneNumber,
          message: errorMessage,
          context: 'ERROR',
          metadata: {
            errorType: 'ai_audio_extraction_error',
            errorMessage: aiError.message,
            transcription,
          },
        });

        return {
          success: false,
          message: errorMessage,
          requiresConfirmation: false,
        };
      }

      // 8. Validar dados extra√≠dos
      const validation = this.validator.validate(transactionData);
      if (!validation.isValid) {
        const errorMessage =
          `‚ùå *N√£o consegui extrair dados v√°lidos*\n\n` +
          `üé§ Ouvi: "${transcription}"\n\n` +
          `${validation.errors.join('\n')}\n\n` +
          `*Dica:* Fale algo como "Gastei 50 reais no mercado"`;

        this.eventEmitter.emit('message.reply', {
          phoneNumber,
          message: errorMessage,
          context: 'ERROR',
          metadata: {
            errorType: 'validation_error',
            errors: validation.errors,
            transcription,
            confidence: transactionData.confidence,
          },
        });

        return {
          success: false,
          message: errorMessage,
          requiresConfirmation: false,
        };
      }

      // 9. Criar confirma√ß√£o
      const confirmation = await this.createConfirmation(phoneNumber, messageId, transactionData);

      // 10. Formatar mensagem
      let message = `üé§ *Ouvi:* "${transcription}"\n\n`;
      message += this.confirmationService.formatConfirmationMessage(confirmation);

      if (validation.warnings.length > 0) {
        message += `\n\n‚ö†Ô∏è *Avisos:*\n${validation.warnings.join('\n')}`;
      }

      if (transactionData.confidence < 0.7) {
        message += '\n\n‚ö†Ô∏è *Confian√ßa m√©dia na extra√ß√£o. Por favor, revise os dados.*';
      }

      // Emitir evento para enviar confirma√ß√£o
      this.eventEmitter.emit('message.reply', {
        phoneNumber,
        message,
        context: 'CONFIRMATION_REQUEST',
        metadata: {
          confirmationId: confirmation.id,
          confidence: transactionData.confidence,
          transcription,
          fromAudio: true,
        },
      });

      return {
        success: true,
        message,
        requiresConfirmation: true,
        confirmationId: confirmation.id,
      };
    } catch (error: any) {
      this.logger.error('Erro ao processar √°udio:', error);

      const errorMessage =
        '‚ùå *Erro inesperado ao processar √°udio*\n\n' +
        'Por favor, tente novamente ou digite a mensagem manualmente.';

      this.eventEmitter.emit('message.reply', {
        phoneNumber,
        message: errorMessage,
        context: 'ERROR',
        metadata: {
          errorType: 'exception',
          errorMessage: error.message,
        },
      });

      return {
        success: false,
        message: errorMessage,
        requiresConfirmation: false,
      };
    }
  }

  /**
   * Processa confirma√ß√£o do usu√°rio (sim/n√£o)
   */
  async processConfirmation(
    phoneNumber: string,
    response: string,
  ): Promise<{ success: boolean; message: string }> {
    try {
      const result = await this.confirmationService.processResponse(phoneNumber, response);

      if (result.action === 'invalid') {
        return {
          success: false,
          message: '‚ùì N√£o h√° transa√ß√£o pendente de confirma√ß√£o.',
        };
      }

      if (result.action === 'rejected') {
        return {
          success: true,
          message: '‚ùå Ok, transa√ß√£o cancelada.',
        };
      }

      if (result.action === 'confirmed' && result.confirmation) {
        // Registrar na API Gasto Certo
        const registered = await this.registerTransaction(result.confirmation);

        if (registered.success) {
          return {
            success: true,
            message: registered.message,
          };
        } else {
          return {
            success: false,
            message: registered.message,
          };
        }
      }

      return {
        success: false,
        message: '‚ùì N√£o entendi sua resposta. Por favor, responda com "sim" ou "n√£o".',
      };
    } catch (error) {
      this.logger.error('Erro ao processar confirma√ß√£o:', error);
      return {
        success: false,
        message: '‚ùå Erro ao processar confirma√ß√£o. Tente novamente.',
      };
    }
  }

  /**
   * Registra transa√ß√£o na API Gasto Certo
   */
  private async registerTransaction(
    confirmation: TransactionConfirmation,
  ): Promise<{ success: boolean; message: string }> {
    try {
      // Buscar usu√°rio
      const user = await this.userCache.getUser(confirmation.phoneNumber);
      if (!user) {
        return {
          success: false,
          message: '‚ùå Erro: usu√°rio n√£o encontrado.',
        };
      }

      this.logger.log(`\nüîç ========== AN√ÅLISE DE CATEGORIA ==========`);
      this.logger.log(`üìã Categoria extra√≠da pela IA: "${confirmation.category}"`);

      // Buscar categorias completas para an√°lise
      const categoriesData = await this.userCache.getUserCategories(confirmation.phoneNumber);

      if (categoriesData.hasCategories) {
        this.logger.log(`üìä ${categoriesData.categories.length} categorias dispon√≠veis:`);

        // Procurar categoria por nome
        const matchingByName = categoriesData.categories.filter(
          (cat: any) => cat.name.toLowerCase() === confirmation.category.toLowerCase(),
        );

        // Procurar categoria por ID (caso j√° seja um UUID)
        const matchingById = categoriesData.categories.filter(
          (cat: any) => cat.id === confirmation.category,
        );

        if (matchingByName.length > 0) {
          this.logger.log(`\n‚úÖ Categorias encontradas por NOME (${matchingByName.length}):`);
          matchingByName.forEach((cat: any) => {
            this.logger.log(
              `  üéØ ${cat.name} | ID: ${cat.id} | Conta: ${cat.accountName} (${cat.accountId}) | Default: ${cat.isDefaultAccount ? 'Sim' : 'N√£o'}`,
            );
          });

          // Priorizar conta default
          const defaultCat = matchingByName.find((cat: any) => cat.isDefaultAccount);
          if (defaultCat) {
            this.logger.log(`\n‚≠ê USANDO categoria da conta DEFAULT:`);
            this.logger.log(
              `   ID: ${defaultCat.id} | Conta: ${defaultCat.accountName} (${defaultCat.accountId})`,
            );
            // Atualizar confirmation.category com o ID correto
            confirmation.category = defaultCat.id;
          } else {
            this.logger.log(`\n‚ö†Ô∏è NENHUMA conta default - usando primeira encontrada:`);
            this.logger.log(
              `   ID: ${matchingByName[0].id} | Conta: ${matchingByName[0].accountName} (${matchingByName[0].accountId})`,
            );
            confirmation.category = matchingByName[0].id;
          }
        } else if (matchingById.length > 0) {
          this.logger.log(`\n‚úÖ Categoria encontrada por ID:`);
          matchingById.forEach((cat: any) => {
            this.logger.log(
              `  üéØ ${cat.name} | ID: ${cat.id} | Conta: ${cat.accountName} (${cat.accountId}) | Default: ${cat.isDefaultAccount ? 'Sim' : 'N√£o'}`,
            );
          });
        } else {
          this.logger.warn(
            `\n‚ö†Ô∏è NENHUMA categoria encontrada! Usando valor original: "${confirmation.category}"`,
          );
        }
      } else {
        this.logger.warn(`‚ö†Ô∏è Nenhuma categoria dispon√≠vel no cache ou API`);
      }

      this.logger.log(`\nüì§ Category ID que ser√° enviado para API: "${confirmation.category}"`);
      this.logger.log(`============================================\n`);

      // Criar DTO para API
      const dto: CreateGastoCertoTransactionDto = {
        userId: user.gastoCertoId,
        type: confirmation.type,
        amount: Number(confirmation.amount),
        categoryId: confirmation.category,
        description: confirmation.description || undefined,
        date: confirmation.date ? confirmation.date.toISOString() : new Date().toISOString(),
        merchant: (confirmation.extractedData as any)?.merchant,
        source: 'whatsapp',
        isCreditCard: false, // Por padr√£o usa banco
      };

      // Registrar via API
      const response = await this.gastoCertoApi.createTransaction(dto);

      // Verificar se foi sucesso
      if (!response.success || !response.transaction) {
        this.logger.error(`‚ùå Erro ao registrar transa√ß√£o: ${response.error?.message}`);

        // üî¥ Emitir evento de erro de API
        this.eventEmitter.emit('message.reply', {
          phoneNumber: confirmation.phoneNumber,
          message: `‚ùå *Erro ao registrar transa√ß√£o*\n\n${response.error?.message || response.message || 'Erro desconhecido na API.'}\n\nPor favor, tente novamente mais tarde.`,
          context: 'ERROR',
          metadata: {
            confirmationId: confirmation.id,
            errorType: 'api_error',
            errorMessage: response.error?.message || response.message,
          },
        });

        return {
          success: false,
          message: `‚ùå ${response.message}`,
        };
      }

      // Registrar em audit log
      await this.logTransaction(confirmation.phoneNumber, confirmation, response.transaction.id);

      // Formatar mensagem de sucesso
      const typeEmoji = confirmation.type === 'EXPENSES' ? 'üí∏' : 'üí∞';
      const typeText = confirmation.type === 'EXPENSES' ? 'Gasto' : 'Receita';
      const amountFormatted = this.validator.formatAmount(Number(confirmation.amount));

      let successMessage = `‚úÖ *${typeText} registrado com sucesso!*\n\n`;
      successMessage += `${typeEmoji} *Valor:* ${amountFormatted}\n`;
      successMessage += `üìÇ *Categoria:* ${confirmation.category}\n`;

      if (confirmation.description) {
        successMessage += `üìù *Descri√ß√£o:* ${confirmation.description}\n`;
      }

      successMessage += `\nüí° Continue enviando suas transa√ß√µes por texto, √°udio ou imagem!`;

      // ‚úÖ Emitir evento de sucesso
      this.eventEmitter.emit('message.reply', {
        phoneNumber: confirmation.phoneNumber,
        message: successMessage,
        context: 'TRANSACTION_RESULT',
        metadata: {
          confirmationId: confirmation.id,
          transactionId: response.transaction.id,
          type: confirmation.type,
          amount: confirmation.amount,
          category: confirmation.category,
        },
      });

      this.logger.log(
        `‚úÖ Evento 'message.reply' emitido para sucesso de registro | Transaction ID: ${response.transaction.id}`,
      );

      return {
        success: true,
        message: successMessage,
      };
    } catch (error: any) {
      this.logger.error('Erro ao registrar transa√ß√£o na API:', error);

      // üî¥ Emitir evento de erro gen√©rico
      this.eventEmitter.emit('message.reply', {
        phoneNumber: confirmation.phoneNumber,
        message:
          '‚ùå *Erro ao registrar transa√ß√£o*\n\n' +
          'Ocorreu um erro inesperado. Por favor, tente novamente mais tarde.\n\n' +
          'Se o problema persistir, entre em contato com o suporte.',
        context: 'ERROR',
        metadata: {
          confirmationId: confirmation.id,
          errorType: 'exception',
          errorMessage: error.message,
        },
      });

      return {
        success: false,
        message: '‚ùå Erro ao registrar transa√ß√£o na API Gasto Certo. Tente novamente mais tarde.',
      };
    }
  }

  /**
   * Cria confirma√ß√£o pendente
   */
  private async createConfirmation(
    phoneNumber: string,
    messageId: string,
    transactionData: TransactionData,
  ): Promise<TransactionConfirmation> {
    this.logger.log(`\nüî® ========== PREPARANDO DTO CONFIRMA√á√ÉO ==========`);
    this.logger.log(`üìû Phone: ${phoneNumber}`);
    this.logger.log(`üì® Message ID: ${messageId}`);
    this.logger.log(`üì¶ Transaction Data:`, JSON.stringify(transactionData, null, 2));

    const normalizedCategory = this.validator.normalizeCategory(transactionData.category);
    const sanitizedDescription = transactionData.description
      ? this.validator.sanitizeDescription(transactionData.description)
      : undefined;

    this.logger.log(
      `üìÇ Category original: "${transactionData.category}" ‚Üí normalized: "${normalizedCategory}"`,
    );
    this.logger.log(`üìù Description sanitized: "${sanitizedDescription || 'N/A'}"`);

    const dto: CreateTransactionConfirmationDto = {
      phoneNumber,
      messageId,
      type: transactionData.type as any,
      amount: transactionData.amount,
      category: normalizedCategory,
      description: sanitizedDescription,
      date: transactionData.date,
      extractedData: transactionData.rawData,
    };

    this.logger.log(`üì§ DTO Final:`, JSON.stringify(dto, null, 2));
    this.logger.log(`===============================================\n`);

    return this.confirmationService.create(dto);
  }

  /**
   * Registra transa√ß√£o em audit log
   */
  private async logTransaction(
    phoneNumber: string,
    confirmation: TransactionConfirmation,
    gastoCertoTransactionId: string,
  ): Promise<void> {
    try {
      await this.prisma.auditLog.create({
        data: {
          phoneNumber,
          action: 'transaction_registered',
          metadata: {
            confirmationId: confirmation.id,
            gastoCertoTransactionId,
            type: confirmation.type,
            amount: Number(confirmation.amount),
            category: confirmation.category,
          },
        },
      });
    } catch (error) {
      this.logger.error('Erro ao registrar audit log:', error);
    }
  }
}
